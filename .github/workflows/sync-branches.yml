name: Sync Upstream Repository

on:
  schedule:
    - cron: '0 0 * * *'  # 每天 UTC 午夜同步一次
  workflow_dispatch:      # 支持手动触发
  repository_dispatch:    # 支持API触发
    types: [sync-requested]

jobs:
  sync-upstream:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # 需要写权限推送分支
      pull-requests: write
      issues: write

    steps:
      - name: 检出当前仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史

      - name: 配置 Git 身份
        run: |
          git config user.name "GitHub Upstream Sync Bot"
          git config user.email "actions@github.com"

      - name: 添加上游仓库
        run: |
          git remote add upstream https://github.com/${{ env.UPSTREAM_REPO }}.git
          git fetch upstream --prune
        env:
          UPSTREAM_REPO: "ymyuuu/IPDB"  # 替换为真实上游仓库

      - name: 获取需要同步的分支
        id: get-branches
        run: |
          # 获取上游所有分支
          UPSTREAM_BRANCHES=$(git ls-remote --heads upstream | awk '{print $2}' | sed 's/refs\/heads\///')
          
          # 获取当前仓库分支
          CURRENT_BRANCHES=$(git branch -r | grep -v 'HEAD' | sed 's/origin\///')
          
          # 找出需要同步的分支（上游存在且当前仓库也存在）
          SYNC_BRANCHES=$(comm -12 <(echo "$UPSTREAM_BRANCHES" | sort) <(echo "$CURRENT_BRANCHES" | sort) | tr '\n' ' ')
          
          echo "需要同步的分支: $SYNC_BRANCHES"
          echo "sync_branches=$SYNC_BRANCHES" >> $GITHUB_OUTPUT
        shell: bash

      - name: 同步分支
        id: sync-branches
        run: |
          # 将分支列表转换为数组
          IFS=' ' read -ra BRANCHES <<< "${{ steps.get-branches.outputs.sync_branches }}"
          
          # 初始化结果变量
          SUCCESS_BRANCHES=""
          FAILED_BRANCHES=""
          CONFLICT_BRANCHES=""
          
          for branch in "${BRANCHES[@]}"; do
            echo "正在同步分支: $branch"
            
            # 检出分支
            git checkout -B $branch origin/$branch
            
            # 尝试合并上游更改
            if git merge --no-commit --no-ff upstream/$branch; then
              git commit -m "🔁 自动同步上游更改: $branch [skip ci]"
              git push origin $branch
              SUCCESS_BRANCHES+="$branch "
              echo "✅ $branch 同步成功"
            else
              # 处理冲突
              git merge --abort
              
              # 创建冲突解决分支
              CONFLICT_BRANCH="sync-conflict-$branch-$(date +%s)"
              git checkout -b $CONFLICT_BRANCH
              git push origin $CONFLICT_BRANCH
              
              # 创建PR
              PR_URL=$(gh pr create --base $branch --head $CONFLICT_BRANCH \
                --title "解决上游同步冲突: $branch" \
                --body "上游同步时检测到冲突，请手动解决。\n\n冲突文件:\n$(git diff --name-only --diff-filter=U)")
              
              FAILED_BRANCHES+="$branch "
              CONFLICT_BRANCHES+="$branch:$PR_URL "
              echo "❌ $branch 同步失败，创建冲突解决PR: $PR_URL"
            fi
          done
          
          # 设置输出变量
          echo "success_branches=$SUCCESS_BRANCHES" >> $GITHUB_OUTPUT
          echo "failed_branches=$FAILED_BRANCHES" >> $GITHUB_OUTPUT
          echo "conflict_branches=$CONFLICT_BRANCHES" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: Slack 通知
        if: ${{ steps.sync-branches.outputs.failed_branches != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: 'C123456'  # 替换为真实频道ID
          slack-message: |
            :arrows_counterclockwise: *上游同步报告*
            ${{ github.repository }} → ${{ env.UPSTREAM_REPO }}
            :white_check_mark: 成功分支: ${{ steps.sync-branches.outputs.success_branches || '无' }}
            :x: 失败分支: ${{ steps.sync-branches.outputs.failed_branches || '无' }}
            :warning: 冲突解决PR: ${{ steps.sync-branches.outputs.conflict_branches || '无' }}
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
